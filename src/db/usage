# Import the module
from kp_db import KP_DB, JoinType, ComparisonOperator, JoinClause, WhereClause, OrderByClause

# Initialize the database connection
db = KP_DB(pool_size=5, chunk_size=500)

# Sample table structure we'll be working with:
# CREATE TABLE users (
#     id INT AUTO_INCREMENT PRIMARY KEY,
#     username VARCHAR(50) NOT NULL,
#     email VARCHAR(100) NOT NULL,
#     status ENUM('active', 'inactive', 'suspended') DEFAULT 'active',
#     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
# );
#
# CREATE TABLE orders (
#     id INT AUTO_INCREMENT PRIMARY KEY,
#     user_id INT NOT NULL,
#     amount DECIMAL(10,2) NOT NULL,
#     status ENUM('pending', 'completed', 'cancelled') DEFAULT 'pending',
#     order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
#     FOREIGN KEY (user_id) REFERENCES users(id)
# );

# INSERT DATA
# Insert a single user
new_user = {
    'username': 'johndoe',
    'email': 'john@example.com',
    'status': 'active'
}
user_id = db.insert('users', new_user)
print(f"Inserted user with ID: {user_id}")

# Insert multiple users
multiple_users = [
    {'username': 'alice', 'email': 'alice@example.com', 'status': 'active'},
    {'username': 'bob', 'email': 'bob@example.com', 'status': 'active'},
    {'username': 'charlie', 'email': 'charlie@example.com', 'status': 'inactive'}
]
inserted_ids = db.insert_many('users', multiple_users, return_ids=True)
print(f"Inserted users with IDs: {inserted_ids}")

# QUERYING DATA
# Get a single user by ID
user = db.get_one('users', where=[
    WhereClause('id', user_id, ComparisonOperator.EQ)
])
print(f"Single user: {user}")

# Get all active users
active_users = db.get_all('users', where=[
    WhereClause('status', 'active', ComparisonOperator.EQ)
])
print(f"Active users: {len(active_users)}")

# Get users with pagination
page1_users = db.get_all('users', 
                        columns=['id', 'username', 'email'],
                        order_by=[OrderByClause('username')],
                        limit=10, offset=0)
print(f"First page users: {page1_users}")

# Get users with complex conditions
complex_users = db.get_all('users', where=[
    WhereClause('status', 'active', ComparisonOperator.EQ),
    WhereClause('created_at', '2023-01-01', ComparisonOperator.GTE, connector='AND'),
    WhereClause('username', '%doe%', ComparisonOperator.LIKE, connector='OR')
])
print(f"Complex query users: {complex_users}")

# UPDATE DATA
# Update a user's email
update_count = db.update('users', 
                       where=[WhereClause('id', user_id, ComparisonOperator.EQ)],
                       data={'email': 'john.new@example.com'})
print(f"Updated {update_count} users")

# Bulk update status
bulk_update_count = db.update('users',
                            where=[WhereClause('status', 'inactive', ComparisonOperator.EQ)],
                            data={'status': 'active'})
print(f"Updated {bulk_update_count} users to active status")

# DELETE DATA
# Delete a user
delete_count = db.delete('users', 
                        where=[WhereClause('id', user_id, ComparisonOperator.EQ)])
print(f"Deleted {delete_count} users")

# Delete inactive users older than a year
old_inactive_count = db.delete('users', where=[
    WhereClause('status', 'inactive', ComparisonOperator.EQ),
    WhereClause('created_at', '2022-01-01', ComparisonOperator.LT, connector='AND')
])
print(f"Deleted {old_inactive_count} old inactive users")

# ADVACED QUERIES
# Get users with their orders using INNER JOIN
user_orders = db.get_all('users',
                        columns=['users.username', 'users.email', 'orders.amount', 'orders.status'],
                        joins=[
                            JoinClause('orders', 'users.id', 'orders.user_id', JoinType.INNER)
                        ],
                        where=[
                            WhereClause('users.status', 'active', ComparisonOperator.EQ)
                        ],
                        order_by=[
                            OrderByClause('users.username'),
                            OrderByClause('orders.order_date', 'DESC')
                        ])
print(f"Users with their orders: {user_orders}")

# LEFT JOIN example
all_users_with_orders = db.get_all('users',
                                 columns=['users.*', 'COUNT(orders.id) AS order_count'],
                                 joins=[
                                     JoinClause('orders', 'users.id', 'orders.user_id', JoinType.LEFT)
                                 ],
                                 group_by='users.id')
print(f"All users with order counts: {all_users_with_orders}")

# Multiple conditions with different operators
complex_query = db.get_all('users', where=[
    WhereClause('status', 'active', ComparisonOperator.EQ),
    WhereClause('created_at', ['2023-01-01', '2023-12-31'], ComparisonOperator.BETWEEN, connector='AND'),
    WhereClause('username', ['alice', 'bob', 'charlie'], ComparisonOperator.IN, connector='OR'),
    WhereClause('email', None, ComparisonOperator.IS_NOT_NULL, connector='AND')
])
print(f"Complex query results: {complex_query}")

# Process large results in chunks without loading everything into memory
for chunk in db.get_all('large_table', stream=True):
    process_chunk(chunk)  # Your custom processing function
    print(f"Processed {len(chunk)} records")

# Or using the built-in chunking
for chunk in db.get_chunked('large_table'):
    process_chunk(chunk)
    print(f"Processed chunk of {len(chunk)} records")

# Using transactions for atomic operations
with db.transaction() as conn:
    try:
        # Create a new user
        new_user_id = db.insert('users', {
            'username': 'transaction_test',
            'email': 'transaction@test.com'
        })
        
        # Create an order for that user
        db.insert('orders', {
            'user_id': new_user_id,
            'amount': 100.00,
            'status': 'pending'
        })
        
        # If we get here, both operations will be committed
        print("Transaction completed successfully")
        
    except Exception as e:
        print(f"Transaction failed: {e}")
        # The transaction will be automatically rolled back

# Calling a stored procedure
# Assume we have a procedure: CREATE PROCEDURE get_user_orders(IN user_id INT)
user_orders = db.call_proc('get_user_orders', args=[1], fetch=True)
print(f"User orders from stored procedure: {user_orders}")

# Calling a procedure that returns multiple result sets
for result_set in db.call_proc('get_multiple_reports', stream=True):
    print(f"Report data: {result_set}")

# Execute raw SQL when needed
custom_query = """
    SELECT u.username, COUNT(o.id) as order_count 
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.status = %s
    GROUP BY u.id
    HAVING order_count > %s
"""
results = db.execute_raw(custom_query, params=('active', 0), fetch=True)
print(f"Custom query results: {results}")

try:
    # Try to insert invalid data
    db.insert('users', {'invalid_column': 'value'})
except Exception as e:
    print(f"Error occurred: {e}")

try:
    # Query with invalid conditions
    db.get_all('users', where=[
        WhereClause('nonexistent_column', 'value', ComparisonOperator.EQ)
    ])
except Exception as e:
    print(f"Query error: {e}")

# The connection pool will be automatically cleaned up when the object is destroyed
# But you can explicitly clean up if needed
del db

# COMPLETE EXAMPLE APP
from kp_db import KP_DB, JoinType, ComparisonOperator, JoinClause, WhereClause, OrderByClause

def main():
    # Initialize database connection
    db = KP_DB(pool_size=5, chunk_size=500)
    
    try:
        # 1. Insert sample data
        users = [
            {'username': 'alice', 'email': 'alice@example.com', 'status': 'active'},
            {'username': 'bob', 'email': 'bob@example.com', 'status': 'active'},
            {'username': 'charlie', 'email': 'charlie@example.com', 'status': 'inactive'}
        ]
        user_ids = db.insert_many('users', users, return_ids=True)
        
        orders = []
        for user_id in user_ids:
            orders.extend([
                {'user_id': user_id, 'amount': 10.50 * (i+1), 'status': 'completed'} 
                for i in range(3)
            ])
        db.insert_many('orders', orders)
        
        # 2. Query examples
        print("\nActive users:")
        active_users = db.get_all('users', where=[
            WhereClause('status', 'active', ComparisonOperator.EQ)
        ])
        for user in active_users:
            print(f"{user['id']}: {user['username']}")
        
        # 3. Join example
        print("\nUsers with their total order amounts:")
        user_totals = db.get_all('users',
                               columns=['users.username', 'SUM(orders.amount) AS total'],
                               joins=[
                                   JoinClause('orders', 'users.id', 'orders.user_id', JoinType.LEFT)
                               ],
                               group_by='users.id')
        for user in user_totals:
            print(f"{user['username']}: ${user['total'] or 0:.2f}")
        
        # 4. Transaction example
        print("\nProcessing transaction...")
        with db.transaction() as conn:
            try:
                # Create new user
                new_id = db.insert('users', {
                    'username': 'transaction_user',
                    'email': 'transaction@example.com'
                })
                
                # Create order
                db.insert('orders', {
                    'user_id': new_id,
                    'amount': 99.99,
                    'status': 'pending'
                })
                
                print("Transaction completed successfully!")
                
            except Exception as e:
                print(f"Transaction failed: {e}")
                raise
        
        # Verify the transaction
        new_user = db.get_one('users', where=[
            WhereClause('username', 'transaction_user', ComparisonOperator.EQ)
        ])
        print(f"New user found: {new_user}")
        
    finally:
        # Clean up
        del db

if __name__ == "__main__":
    main()